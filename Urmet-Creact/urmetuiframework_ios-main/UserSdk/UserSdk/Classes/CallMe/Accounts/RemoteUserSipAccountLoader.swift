//
//  RemoteUserSipAccountLoader.swift
//  CallMeSdk
//
//  Created by Matteo Cioppa on 18/10/22.
//

import Foundation

final class RemoteUserSipAccountLoader: AccountLoader {
    private let userSipDataService: IUserSipDataService
    private let autogeneratedCredentialsFactory: AutogeneratedCredentialsFactory.Type
    private let createSipAccountService: ICreateSipAccountService
    private let accountStore: AccountStore
    private let realm: String

    public enum Error: Swift.Error {
        case connectivity
        case unauthorized
        case invalidData
    }

    init(
        userSipDataService: IUserSipDataService,
        createSipAccountService: ICreateSipAccountService,
        accountStore: AccountStore,
        realm: String
    ) {
        self.userSipDataService = userSipDataService
        autogeneratedCredentialsFactory = AutogeneratedCredentialsFactory.self
        self.createSipAccountService = createSipAccountService
        self.accountStore = accountStore
        self.realm = realm
    }

    func load(completion: @escaping Completion) {
        accountStore.retrieve { [weak self] result in
            guard let self else { return }

            switch result {
            case let .success(accounts):
                if self.isCfwAccountPresent(accounts) {
                    return completion(.success(true))
                } else {
                    self.loadUserSipData(completion: completion)
                }

            case .failure:
                completion(.failure(RemoteUserSipAccountLoader.Error.invalidData))
            }
        }
    }

    private func isCfwAccountPresent(_ accounts: [Account]) -> Bool {
        return accounts.filter { $0.direction == .bidirectional }.count > 0
    }

    private func loadUserSipData(completion: @escaping Completion) {
        userSipDataService.get { [weak self] result in
            guard let self else { return }

            switch result {
            case let .failure(error as UserSipDataService.Error):
                self.handleUserSipDataServiceFailure(error, completion: completion)

            case let .success(userSipData):
                self.persistUserSipData(userSipData, completion: completion)

            default:
                completion(.failure(RemoteUserSipAccountLoader.Error.connectivity))
            }
        }
    }

    private func persistUserSipData(_ userSipData: UserSipData, completion: @escaping Completion) {
        let sipAccount = userSipData.currentSipCredentials
        let account = Account(
            username: sipAccount.username,
            password: sipAccount.password,
            realm: sipAccount.realm,
            direction: .bidirectional,
            placeID: "",
            channelNumber: Int.max
        )

        accountStore.insert(account: account) { _ in
            completion(.success(true))
        }
    }

    private func handleUserSipDataServiceFailure(_ error: UserSipDataService.Error, completion: @escaping Completion) {
        switch error {
        case .connectivity:
            return completion(.failure(RemoteUserSipAccountLoader.Error.connectivity))
        case .unauthorized:
            return completion(.failure(RemoteUserSipAccountLoader.Error.unauthorized))
        case .invalidData:
            return completion(.failure(RemoteUserSipAccountLoader.Error.invalidData))
        case .dataNotFound:
            createUserAutogeneratedSipAccount(completion: completion)
        }
    }

    private func createUserAutogeneratedSipAccount(completion: @escaping Completion) {
        let account = autogeneratedCredentialsFactory.makeCredentials(forRealm: realm)

        createSipAccountService.create(accountWithUsername: account.username, andPassword: account.password, forRealm: account.realm) { [weak self] result in
            guard let self else { return }

            switch result {
            case .success:
                self.saveUserAutogeneratedSipAccount(account, completion: completion)

            case let .failure(error as CreateSipAccountService.Error):
                self.handleCreateUserAutogeneratedSipAccountFailure(error, completion: completion)

            default:
                completion(.failure(RemoteUserSipAccountLoader.Error.connectivity))
            }
        }
    }

    private func handleCreateUserAutogeneratedSipAccountFailure(_ error: CreateSipAccountService.Error, completion: @escaping Completion) {
        switch error {
        case .connectivity:
            return completion(.failure(RemoteUserSipAccountLoader.Error.connectivity))
        case .unauthorized:
            return completion(.failure(RemoteUserSipAccountLoader.Error.unauthorized))
        case .invalidData:
            return completion(.failure(RemoteUserSipAccountLoader.Error.invalidData))
        }
    }

    private func saveUserAutogeneratedSipAccount(_ account: UserSipDataAccount, completion: @escaping Completion) {
        let userSipData = UserSipData(currentSipCredentialsType: .TYPE_AUTOGENERATED, existingSipCredentials: nil, autogeneratedSipCredentials: account)

        userSipDataService.set(sipData: userSipData) { [weak self] result in
            guard let self else { return }

            switch result {
            case .success:
                self.loadUserSipData(completion: completion)

            case let .failure(error as UserSipDataService.Error):
                self.handleUserSipDataServiceFailure(error, completion: completion)

            case .failure:
                return completion(.failure(RemoteUserSipAccountLoader.Error.connectivity))
            }
        }
    }
}
